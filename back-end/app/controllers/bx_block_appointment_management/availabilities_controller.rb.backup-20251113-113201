module BxBlockAppointmentManagement
  class AvailabilitiesController < ApplicationController
    before_action :set_current_user, only: [:create, :delete_all]

    def index
      unless params[:service_provider_id].blank? || params[:availability_date].blank?
        begin
          # Parse date consistently with admin portal format (DD/MM/YYYY)
          parsed_date = parse_availability_date(params[:availability_date])
          formatted_date = parsed_date.strftime('%d/%m/%Y')
          
          availability = Availability.find_by(
            service_provider_id: params[:service_provider_id],
            availability_date: formatted_date
          )
          render json: {
            message: "No slots present for date #{formatted_date}"
          } and return unless availability.present?
          render json: ServiceProviderAvailabilitySerializer.new(
            availability, meta: {message: 'List of all slots'}
          )
        rescue ArgumentError => e
          render json: {errors: [
            {availability_date: "Invalid date format. Expected DD/MM/YYYY, got: #{params[:availability_date]}"}
          ]}, status: :unprocessable_entity
        end
      else
        render json: {errors: [
          {availability: 'Date or Service provider Account id is empty'},
        ]}, status: :unprocessable_entity
      end
    end


    def create
      begin
        # Normalize availability_date to DD/MM/YYYY format if provided
        params_hash = availability_params.to_h
        if params_hash[:availability_date].present?
          parsed_date = parse_availability_date(params_hash[:availability_date])
          params_hash[:availability_date] = parsed_date.strftime('%d/%m/%Y')
        end
        
        availability = Availability.new(
          params_hash.merge(service_provider_id: @current_user.id)
        )
        if availability.save
          trigger_slot_worker(availability)
          render json: ServiceProviderAvailabilitySerializer.new(availability)
        else
          render json: { errors: [{slot_error: availability.errors.full_messages.first}] },
                 status: :unprocessable_entity
        end
      rescue ArgumentError => e
        render json: { errors: [{availability_date: "Invalid date format. Expected DD/MM/YYYY, got: #{params[:availability][:availability_date]}"}] },
               status: :unprocessable_entity
      end
    end

    def delete_all
      BxBlockAppointmentManagement::Availability.where(
        service_provider: @current_user
      ).destroy_all
    end

    private

    def availability_params
      params.require(:availability).permit(:start_time, :end_time, :availability_date)
    end

    def trigger_slot_worker availability
      BxBlockAppointmentManagement::CreateAvailabilityWorker.perform_async(availability.id)
    end

    def set_current_user
      @current_user = AccountBlock::Account.find(@token.id)
    end

    def parse_availability_date(date_str)
      # Try DD/MM/YYYY format first (consistent with admin portal)
      if date_str.is_a?(String) && date_str.match?(/\d{2}\/\d{2}\/\d{4}/)
        Date.strptime(date_str, "%d/%m/%Y")
      # Try YYYY-MM-DD format (common API format)
      elsif date_str.is_a?(String) && date_str.match?(/\d{4}-\d{2}-\d{2}/)
        Date.strptime(date_str, "%Y-%m-%d")
      # Fallback to Date.parse (less reliable)
      else
        Date.parse(date_str)
      end
    rescue ArgumentError => e
      raise ArgumentError, "Invalid date format. Expected DD/MM/YYYY or YYYY-MM-DD, got: #{date_str}"
    end
  end
end
